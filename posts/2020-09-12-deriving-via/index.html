<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Overriding Type Class Instances — Daniel Winograd-Cort</title>
    
    <meta name="keywords" content="haskell, row-types, instances, DerivingVia">

    <link rel="shortcut icon" type="image/x-icon" href="../../images/haskell-logo.png?format=100w" />  <!-- href="/favicon.ico?format=100w" -->
    <link rel="canonical" href="http://www.danwc.com" />
    <meta property="og:site_name" content="Daniel Winograd‑Cort" />
    <meta property="og:title" content="Overriding Type Class Instances — Daniel Winograd-Cort" />
    <meta property="og:url" content="https://danwc.com/posts/2020-09-12-deriving-via/index.html" />
    <meta property="og:type" content="website" />
    <meta itemprop="name" content="Overriding Type Class Instances — Daniel Winograd-Cort" />
    <meta itemprop="url" content="https://danwc.com/posts/2020-09-12-deriving-via/index.html" />
    <meta name="twitter:title" content="Daniel Winograd‑Cort" />
    <meta name="twitter:url" content="https://danwc.com/posts/2020-09-12-deriving-via/index.html" />
    <meta name="twitter:card" content="summary" />
    <meta name="description" content />

    <link rel="stylesheet" href="../../css/default.css" />
  </head>
  <body>
    <header>
      <div class="site-title">
        <h1 class="site-title site-title">
          <a href="../../" title="Daniel Winograd‑Cort">
            <span>Daniel Winograd‑Cort</span>
          </a>
        </h1>
      </div>
      <div class="site-description">
        <p>Co-Founder and CTO of Nectry</p>
      </div>

      <nav>
        <a href="../../posts">Posts</a>
        <a href="../../research">Research</a>
        <a href="../../projects">Projects</a>
        <a href="../../teaching">Teaching</a>
        <a href="../../data/danwc-resume.pdf" target="_blank">Resume</a>
        <a href="../../personal">Personal</a>
        <a href="../../contact">Contact</a>
      </nav>
    </header>

    <main role="main">
      <article>
    <section class="header">
        
        Re-posted on September 12, 2020 (originally written April 10, 2020)
        
    </section>
    <section>
        <link rel="stylesheet" href="../../css/syntax.css" />
        <h1 id="overriding-type-class-instances">Overriding Type Class Instances</h1>
<p>I read a post by Cary Robbins titled <a href="http://caryrobbins.com/dev/overriding-type-class-instances-2/">Overriding Type Class Instances</a> that describes a clever way to derive custom type class instances for types using some type-level programming tricks and the <code>DerivingVia</code> extension. It struck me that row-types should be able to do nearly the same thing almost for free, and I took it as a challenge to see if I could make it work. It required a minor change to the library (the addition of a specialized <code>coerce</code> function for records), but otherwise it was quite straightforward.</p>
<h2 id="example">Example</h2>
<details class="code-details">
<p><summary>Extensions and imports for this Literate Haskell file</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE DerivingVia #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">module</span> <span class="dt">OverridingTypeClassInstances</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">-- Note that `Data.Row.Aeson` is not exported my the row-types library and</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">-- currently lives in the src\aeson directory.  You must put it in an</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">-- appropriate place and make sure to have `aeson` in your environment in order</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">-- to use this module.</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span>           <span class="dt">Data.Aeson</span>       (<span class="dt">ToJSON</span>(..))</a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">import</span>           <span class="dt">Data.Char</span>        (ord, toUpper)</a>
<a class="sourceLine" id="cb1-13" title="13"><span class="kw">import</span>           <span class="dt">Data.Coerce</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="kw">import</span>           <span class="dt">Data.Row</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="kw">import</span>           <span class="dt">Data.Row.Aeson</span>   ()</a>
<a class="sourceLine" id="cb1-16" title="16"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Row.Records</span> <span class="kw">as</span> <span class="dt">Rec</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="kw">import</span>           <span class="dt">Data.Text</span>        (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb1-18" title="18"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span>        <span class="kw">as</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="kw">import</span>           <span class="dt">GHC.Generics</span>     (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="kw">newtype</span> <span class="dt">Uptext</span> <span class="fu">=</span> <span class="dt">Uptext</span> {<span class="ot"> unUptext ::</span> <span class="dt">Text</span> }</a>
<a class="sourceLine" id="cb1-22" title="22"></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Uptext</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-24" title="24">  toJSON <span class="fu">=</span> toJSON <span class="fu">.</span> Text.toUpper <span class="fu">.</span> unUptext</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="kw">newtype</span> <span class="dt">CharArray</span> <span class="fu">=</span> <span class="dt">CharArray</span> {<span class="ot"> unCharArray ::</span> <span class="dt">String</span> }</a>
<a class="sourceLine" id="cb1-27" title="27"></a>
<a class="sourceLine" id="cb1-28" title="28"><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">CharArray</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-29" title="29">  toJSON <span class="fu">=</span> toJSON <span class="fu">.</span> <span class="fu">map</span> (<span class="fu">:</span>[]) <span class="fu">.</span> unCharArray</a></code></pre></div>
</details>
<p>Cary’s result looks like the following:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">MyRec</span> <span class="fu">=</span> <span class="dt">MyRec</span></a>
<a class="sourceLine" id="cb2-2" title="2">  {<span class="ot"> foo ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-3" title="3">  ,<span class="ot"> bar ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-4" title="4">  ,<span class="ot"> baz ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-5" title="5">  } <span class="kw">deriving</span> stock (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="kw">deriving</span> (<span class="dt">ToJSON</span>)</a>
<a class="sourceLine" id="cb2-7" title="7">      via <span class="dt">Override</span> <span class="dt">MyRec</span></a>
<a class="sourceLine" id="cb2-8" title="8">            '[ <span class="dt">String</span> <span class="ot">`As`</span> <span class="dt">CharArray</span></a>
<a class="sourceLine" id="cb2-9" title="9">             , <span class="st">&quot;baz&quot;</span> <span class="ot">`As`</span> <span class="dt">Uptext</span></a>
<a class="sourceLine" id="cb2-10" title="10">             ]</a></code></pre></div>
<p>The idea here is that the <code>MyRec</code> data type can have a <code>ToJSON</code> instance where all <code>String</code> fields are encoded using the <code>ToJSON</code> functionality of the <code>CharArray</code> type class and the <code>baz</code> field is encoded using the <code>ToJSON</code> of <code>Uptext</code>. The rest of Cary’s post describes how he accomplishes this.</p>
<p>With row-types, it’s currently not possible to do a wholesale modification based on types, but we certainly have machinery for modifying individual fields. Thus instead, I propose a slightly different syntax, this time based on row-types operators:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">MyRec</span> <span class="fu">=</span> <span class="dt">MyRec</span></a>
<a class="sourceLine" id="cb3-2" title="2">  {<span class="ot"> foo ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-3" title="3">  ,<span class="ot"> bar ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-4" title="4">  ,<span class="ot"> baz ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-5" title="5">  } <span class="kw">deriving</span> stock (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="kw">deriving</span> (<span class="dt">ToJSON</span>)</a>
<a class="sourceLine" id="cb3-7" title="7">      via <span class="dt">Override</span> <span class="dt">MyRec</span> (</a>
<a class="sourceLine" id="cb3-8" title="8">           <span class="st">&quot;bar&quot;</span> <span class="fu">.==</span> <span class="dt">CharArray</span></a>
<a class="sourceLine" id="cb3-9" title="9">        <span class="fu">.+</span> <span class="st">&quot;baz&quot;</span> <span class="fu">.==</span> <span class="dt">Uptext</span>)</a></code></pre></div>
<h2 id="details">Details</h2>
<p>The <code>Override</code> type is actually very simple:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">newtype</span> <span class="dt">Override</span> t (<span class="ot">mods ::</span> <span class="dt">Row</span> <span class="fu">*</span>) <span class="fu">=</span> <span class="dt">Override</span> {<span class="ot"> unOverride ::</span> t }</a></code></pre></div>
<p>A value of type <code>Override t mods</code> is a value of type <code>t</code> that will have certain fields overridden according to <code>mods</code>. The key is in how we define the <code>ToJSON</code> instance for <code>Override</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb5-2" title="2">  ( ρ ≈ <span class="dt">Rec.NativeRow</span> t</a>
<a class="sourceLine" id="cb5-3" title="3">  , ρ' ≈ mods <span class="fu">.//</span> ρ</a>
<a class="sourceLine" id="cb5-4" title="4">  , <span class="dt">BiForall</span> ρ ρ' <span class="dt">Coercible</span></a>
<a class="sourceLine" id="cb5-5" title="5">  , <span class="dt">Rec.FromNative</span> t</a>
<a class="sourceLine" id="cb5-6" title="6">  , <span class="dt">Forall</span> ρ' <span class="dt">ToJSON</span></a>
<a class="sourceLine" id="cb5-7" title="7">  ) <span class="ot">=&gt;</span> <span class="dt">ToJSON</span> (<span class="dt">Override</span> t mods) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-8" title="8">  toJSON <span class="fu">=</span> toJSON <span class="fu">.</span> Rec.coerceRec <span class="fu">@</span>ρ <span class="fu">@</span>ρ' <span class="fu">.</span> Rec.fromNative <span class="fu">.</span> unOverride</a></code></pre></div>
<p>This may look a little intimidating, so let’s take it piece by piece. I’ll start with <code>unOverride</code> and work through the composed functions, calling out elements of the context as they become relevant and necessary.</p>
<ul>
<li><p><code>unOverride</code> is the simplest component. We must unwrap the <code>Override</code> newtype.</p></li>
<li><p><code>Rec.fromNative</code> is a convenient function for converting a native Haskell data type value into a row-types record. It produces a record with exactly the same fields and types as the given record. For instance, when called on a value of type <code>MyRec</code>, it will produce a value of type <code>Rec ("foo" .== Int .+ "bar" .== String .+ "baz" .== Text)</code>. In order to do this, we need the constraint <code>Rec.FromNative t</code>, and it additionally provides a type synonym <code>Rec.NativeRow t</code> which will be equal to the row-type produced. You can see that in the instance’s context above, we bind the type variable <code>ρ</code> to this type.</p></li>
<li><p><code>Rec.coerceRec @ρ @ρ'</code> is a record coercion turning a record with row-type <code>ρ</code> to one of of type <code>ρ'</code>. This will only succeed if all of the types in <code>ρ</code> match up and are coercible with all the types in <code>ρ'</code>, a fact that is captured by the constraint <code>BiForall ρ ρ' Coercible</code>. What is <code>ρ'</code>? It is precisely <code>ρ</code>, but overwritten with any row bindings in <code>mods</code> (this is captured in <code>ρ' ≈ mods .// ρ</code>). For example, <code>("bar" .== CharArray) .// ("foo" .== Int .+ "bar" .== String .+ "baz" .== Text)</code> becomes <code>("foo" .== Int .+ "bar" .== CharArray .+ "baz" .== Text)</code>.</p></li>
<li><p><code>toJSON</code> is the <code>toJSON</code> function specialized to records with type <code>ρ'</code>, and it requires the constraint <code>Forall ρ' ToJSON</code>, indicating that every field in <code>ρ'</code> must have its own <code>ToJSON</code> instance.</p></li>
</ul>
<p>Phew! What does that all mean? It means we can take a value of type <code>t</code>, convert it to a row-types record, coerce any internal types to newtypes with <code>ToJSON</code> instances we prefer, and then produce the JSON of the result all in one go. And it works! It’s true that the instance definition is a little hairy, but thankfully we don’t need to mess around with any <code>Generic</code> code.</p>
<h2 id="exploring-overrides">Exploring Overrides</h2>
<p>Cary defines an <code>override</code> shorthand and then proceeds to demo some examples. I’ll do the same.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="co">-- | A version of 'Override' that accepts first the value and then the mods type.</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">override ::</span> a <span class="ot">-&gt;</span> (<span class="kw">forall</span> mods<span class="fu">.</span> <span class="dt">Override</span> a mods)</a>
<a class="sourceLine" id="cb6-3" title="3">override <span class="fu">=</span> <span class="dt">Override</span></a></code></pre></div>
<p>Now we can write statements in GHCi like:</p>
<pre><code>&gt; v = MyRec 3 &quot;foo&quot; &quot;text&quot;
&gt; encode $ override v @Empty
{&quot;foo&quot;:3,&quot;baz&quot;:&quot;text&quot;,&quot;bar&quot;:&quot;foo&quot;}

&gt; encode $ override v @(&quot;bar&quot; .== CharArray .+ &quot;baz&quot; .== Uptext)
{&quot;foo&quot;:3,&quot;baz&quot;:&quot;TEXT&quot;,&quot;bar&quot;:[&quot;f&quot;,&quot;o&quot;,&quot;o&quot;]}</code></pre>
<p>We also get pretty good type errors when we do things wrong. For instance, if we try to override the same field more than once:</p>
<pre><code>&gt; encode $ override v @(&quot;bar&quot; .== CharArray .+ &quot;bar&quot; .== String)
&lt;interactive&gt;:4:1: error:
    • The label &quot;bar&quot; has conflicting assignments.
      Its type is both CharArray and String.
    • In the expression:
        encode $ override v @(&quot;bar&quot; .== CharArray .+ &quot;bar&quot; .== String)
      In an equation for ‘it’:
          it
            = encode $ override v @(&quot;bar&quot; .== CharArray .+ &quot;bar&quot; .== IntChar)</code></pre>
<p>Alternatively, if you try to coerce to a type that’s not coercible, you’ll get a good error:</p>
<pre><code>&gt; encode $ override v @(&quot;bar&quot; .== Int)
&lt;interactive&gt;:5:1: error:
    • Couldn't match representation of type ‘[Char]’ with that of ‘Int’
        arising from a use of ‘encode’
    • In the expression: encode $ override v @(&quot;bar&quot; .== Int)
      In an equation for ‘it’: it = encode $ override v @(&quot;bar&quot; .== Int)</code></pre>
<h2 id="achievements-and-limitations">Achievements and Limitations</h2>
<p>With a simple <code>newtype</code> and a one-line <code>ToJSON</code> instance (the implementation of the instance is a simple one line, although I’ll admit the context takes a few more), we’ve been able to recreate most of the expressiveness of <code>generic-override</code>. Of course, <code>generic-override</code> has one feature that we don’t: namely, being able to override all fields of a particular type in one go. I can definitely see the use for this feature—for instance, making sure <em>all</em> <code>Text</code> fields are encoded in a consistent, perhaps more concise, way—but I don’t see a way to do it elegantly with row-types at this time.<sup><a href="#myfootnote1">1</a></sup></p>
<p>But we do gain for what we’ve given up. Without needing a <code>ValidateOverride</code> type class, we have clear restrictions (and informative error messages) that prevent us from duplicate overriding. Additionally, we of course have all the other benefits of row-types.</p>
<hr />
<p><a name="myfootnote1">1</a>: If/When GHC adopts the ability to use simple, unsaturated type families, this will become possible. For instance, one could write something like</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">ToUptext</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="dt">ToUptext</span> <span class="dt">Text</span> <span class="fu">=</span> <span class="dt">Uptext</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="dt">ToUptext</span> x <span class="fu">=</span> x</a></code></pre></div>
<p>and then make the override modifications: <code>Rec.Map ToUptext (Rec.NativeRow MyRec)</code>. This in itself is still slightly ugly, but unsaturated type families give us the ability to write more higher-order type functions, such as a row-types <code>Filter</code>. From there, it’s a brief hop to a type-level function <code>FieldsOfTo MyRec Text Uptext</code> which would produce a row-type containing all of the fields of <code>MyRec</code> that had the type <code>Text</code>, now with the type <code>Uptext</code>. Just <code>.+</code> that with any other type modifications you want to make, and you’re all set.</p>
    </section>
<script src="https://giscus.app/client.js" data-repo="dwincort/dwincort.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyNjI3OTE3NTQ=" data-category="Post Comments" data-category-id="DIC_kwDOD6niSs4B_3eK" data-mapping="pathname" data-reactions-enabled="1" data-emit-metadata="0" data-theme="dark" data-lang="en" crossorigin="anonymous" async>
</script>
</article>

    </main>

    <footer>
      <quote>
        <blockquote data-animation-role="quote">
          quotetext
        </blockquote>
        <figcaption class="source">&mdash; quoteattrib</figcaption>
      </quote>
      <p> Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
    </footer>

  <script>
    var myQs = new Array();
    myQs[0] = "Real stupidity beats artificial intelligence every time. -- Terry Pratchett";
    myQs[1] = "He who wonders discovers that this in itself is wonder. -- M. C. Escher";
    myQs[2] = "Simplicity is the ultimate sophistication. -- Leonardo da Vinci";
    myQs[3] = "Time is like a drug. Too much of it kills you. -- Terry Pratchett";
    myQs[4] = "When it came to getting weird things done, sane beat mad hands down. -- Terry Pratchett";
    myQs[5] = "Students, eh? Love 'em or hate 'em, you're not allowed to hit 'em with a shovel. -- Terry Pratchett";
    myQs[6] = "You get ideas from daydreaming. You get ideas from being bored. You get ideas all the time. -- Neil Gaiman";
    myQs[7] = "I don't know half of you half as well as I should like; and I like less than half of you half as well as you deserve. -- Bilbo Baggins, from J.R.R Tolkien's Lord of the Rings";
    myQs[8] = "Only the insane equate pain with success. -- Cheshire Cat, from American Mcgee's Alice";
    myQs[9] = "Only a few find the way; some don't recognize it when they do; some don't ever want to. -- Cheshire Cat, from American Mcgee's Alice";
    myQs[10] = "Always collect what's useful. Reject only your ignorance, and you may survive. -- Cheshire Cat, from American Mcgee's Alice";
    myQs[11] = "Those who say there's nothing like a nice cup of tea for calming the nerves never had real tea. It's like a syringe of adrenaline straight to the heart! -- Cheshire Cat, from American Mcgee's Alice";
    myQs[12] = "My, Earth really is full of things -- King of All Cosmos, from Katamari Damacy";
    myQs[13] = "The way I see it, if you're going to build a time machine into a car, why not do it with some style? -- Doc, from Back to the Future";
    myQs[14] = "I know because I was there. -- Wadsworth, from Clue";
    myQs[15] = "No meaning yes, or no meaning no? -- Colonel Mustard, from Clue";
    myQs[16] = "I feel like I could... like I could... like I could... TAKE ON THE WORLD!! -- Purple Tentacle, from Day of the Tentacle";
    myQs[17] = "You know what they say: \"If you want to save the world, you have to push a few old ladies down the stairs\". -- Bernard, from Day of the Tentacle";
    myQs[18] = "Wait, I’ve got an idea, and it doesn’t require high explosives. -- Max, from Sam'n'Max Hit the Road";
    myQs[19] = "You have this really convenient subspace highway running through your head that I like to use. It's, like, 3 miles in 15 seconds. -- Ramona, from Scott Pilgrim vs The World";
    myQs[20] = "Do you think that's air you're breathing now?  Stop trying to hit me and hit me! -- Morpheus, from The Matrix";
    myQs[21] = "Ray, when someone asks you if you're a god, you say \"Yes!\" -- Winston, from Ghostbusters";
    myQs[22] = "So, Lone Starr, now you see that evil will always triumph, because good is dumb. -- Dark Helmet, from Spaceballs";
    myQs[23] = "People assume that time is a strict progression of cause to effect, but actually — from a non-linear, non-subjective viewpoint — it's more like a big ball of wibbly-wobbly... timey-wimey... stuff. -- Doctor Who";
    myQs[24] = "I must not fear. Fear is the mind-killer. Fear is the little-death that brings total obliteration. -- Paul Atreides, from Frank Herbert's Dune";
    myQs[25] = "Science fiction writers foresee the inevitable, and although problems and catastrophes may be inevitable, solutions are not. -- Isaac Asimov";
    myQs[26] = "To succeed, planning alone is insufficient. One must improvise as well. -- Isaac Asimov";
    myQs[27] = "Remember - the enemy's gate is down. -- Ender, from Orson Scott Card's Ender's Game";
    myQs[28] = "Space is big. Really big. You just won't believe how vastly, hugely, mindbogglingly big it is. I mean, you may think it's a long way down the road to the chemist's, but that's just peanuts to space. -- Douglas Adams, The Hitchhiker's Guide to the Galaxy";
    myQs[29] = "The chances of finding out what's really going on in the universe are so remote, the only thing to do is hang the sense of it and keep yourself occupied. -- Douglas Adams, The Hitchhiker's Guide to the Galaxy";
    myQs[30] = "Hey, you sass that hoopy Ford Prefect? There's a frood who really knows where his towel is. -- Douglas Adams, The Hitchhiker's Guide to the Galaxy";
    myQs[31] = "There's always money in the banana stand. -- George Bluth, from Arrested Development";
    myQs[32] = "Introducing \"the double decker couch\", so everyone could watch TV together and be buddies! -- Emmet, from The Lego Movie";
    myQs[33] = "Ah! Curse your sudden but inevitable betrayal! -- Wash, from Firefly";
    myQs[34] = "Nothing can happen till you swing the bat. -- Haruko, from FLCL";
    myQs[35] = "Dear God. What is it like in your funny little brains? It must be so boring. -- Sherlock";
    myQs[36] = "You, [subject name here], must be the pride of [subject hometown here]! -- GLaDOS, from Portal";
    myQs[37] = "Please note that we have added a consequence for failure. Any contact with the chamber floor will result in an \"unsatisfactory\" mark on your official testing record, followed by death. Good luck! -- GLaDOS, from Portal";
    myQs[38] = "Did you know you can donate one or all of your vital organs to the Aperture Science Self-Esteem Fund for Girls? It's true! -- GLaDOS, from Portal";
    myQs[39] = "You euthanized your faithful Companion Cube more quickly than any test subject on record. Congratulations. -- GLaDOS, from Portal";
    myQs[40] = "Look at me still talking when there's Science to do -- GLaDOS, from Portal";
    myQs[41] = "The Human Mind: 600 miles of synaptic fiber, five and a half ounces of cranial fluid, 1500 grams of complex neural matter... a three-pound pile of dreams. -- Raz, from Psychonauts";


    var range = myQs.length;
    var index;
    var quote;
    var res;
    var attribution;
    var bodyGrab;

    function getQuote()
    {
      index = Math.floor(Math.random()*range);
      quote = myQs[index];
      res = quote.split(" -- ");
      quote = res[0];
      attribution = res[1];
    }

    var blocks = document.getElementsByTagName("blockquote");
    var captions = document.getElementsByTagName("figcaption");
    for (var i=0;i<blocks.length;i++)
    {
      getQuote();
      bodyGrab = blocks[i].innerHTML;
      bodyGrab = bodyGrab.replace("quotetext", quote);
      blocks[i].innerHTML = bodyGrab;
      bodyGrab = captions[i].innerHTML;
      bodyGrab = bodyGrab.replace("quoteattrib", attribution);
      captions[i].innerHTML = bodyGrab;
    }
  </script>
  </body>
</html>
