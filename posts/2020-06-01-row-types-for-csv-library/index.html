<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Row types for CSV library — Daniel Winograd-Cort</title>
    
    <meta name="keywords" content="haskell, row-types, csv">

    <link rel="shortcut icon" type="image/x-icon" href="../../images/haskell-logo.png?format=100w" />  <!-- href="/favicon.ico?format=100w" -->
    <link rel="canonical" href="http://www.danwc.com" />
    <meta property="og:site_name" content="Daniel Winograd‑Cort" />
    <meta property="og:title" content="Row types for CSV library — Daniel Winograd-Cort" />
    <meta property="og:url" content="https://danwc.com/posts/2020-06-01-row-types-for-csv-library/index.html" />
    <meta property="og:type" content="website" />
    <meta itemprop="name" content="Row types for CSV library — Daniel Winograd-Cort" />
    <meta itemprop="url" content="https://danwc.com/posts/2020-06-01-row-types-for-csv-library/index.html" />
    <meta name="twitter:title" content="Daniel Winograd‑Cort" />
    <meta name="twitter:url" content="https://danwc.com/posts/2020-06-01-row-types-for-csv-library/index.html" />
    <meta name="twitter:card" content="summary" />
    <meta name="description" content />

    <link rel="stylesheet" href="../../css/default.css" />
  </head>
  <body>
    <header>
      <div class="site-title">
        <h1 class="site-title site-title">
          <a href="../../" title="Daniel Winograd‑Cort">
            <span>Daniel Winograd‑Cort</span>
          </a>
        </h1>
      </div>
      <div class="site-description">
        <p>Senior Software Engineer at Luminous Computing</p>
      </div>

      <nav>
        <a href="../../posts">Posts</a>
        <a href="../../research">Research</a>
        <a href="../../projects">Projects</a>
        <a href="../../teaching">Teaching</a>
        <a href="../../data/danwc-resume.pdf" target="_blank">Resume</a>
        <a href="../../personal">Personal</a>
        <a href="../../contact">Contact</a>
      </nav>
    </header>

    <main role="main">
      <article>
    <section class="header">
        
        Re-posted on June  1, 2020 (originally written July 23, 2019)
        
    </section>
    <section>
        <link rel="stylesheet" href="../../css/syntax.css" />
        <h1 id="row-types-for-csv-library">Row types for CSV library</h1>
<p>Oleg Grenrus wrote a recent post titled <a href="http://oleg.fi/gists/posts/2019-07-15-fancy-types-for-cassava.html">“Fancy types for CSV library”</a>. In it, he shows how to use vectors and other <em>fancy types</em> to make CSV encoding and decoding more type safe (as compared to <code>cassava</code>). It’s a clever idea that uses an ordered vector of encoded fields (with length at the type level) as an intermediate data type. Thus, for encoding, one encodes their chosen data types into these vectors and then encodes the vectors into csv text. For decoding, one decodes the csv text into vectors and then decodes those vectors into the data types. Some trouble arises during decoding—perhaps the order of values in the csv input is different from the order in the data type, or perhaps there are missing fields in the csv input—and Oleg describes some nice tricks to deal with these problems.</p>
<p>At the end of the article, Oleg writes:</p>
<blockquote>
<p>One valid question to ask, is whether row-types would simplify something here. Not really.</p>
<p>For example vinyl’s Rec type is essentially the same as NP. Even if there were anonymous records in Haskell, so toRecord could be implemented directly using a built-in function, it would remove only a single problem from many. At it’s not much, as toRecord is generically derivable.</p>
</blockquote>
<p>I disagree with this conclusion, and in this post, I’ll show how simple the whole process of csv encoding and decoding can be with the row-types library. In fact, not only is the code short and clear, but it has even more type safety than Oleg’s version.</p>
<h2 id="example">Example</h2>
<details class="code-details">
<p><summary>Extensions and imports for this Literate Haskell file</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">{-# LANGUAGE PartialTypeSignatures #-}</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">module</span> <span class="dt">RowCSV</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">import</span> <span class="dt">GHC.Generics</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span>    <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span>    <span class="kw">as</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="kw">import</span> <span class="dt">Text.Read</span> (readMaybe)</a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="kw">import</span> <span class="dt">Data.Row</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Row.Records</span> <span class="kw">as</span> <span class="dt">Rec</span></a></code></pre></div>
</details>
<p>I’ll start with the same data that Oleg uses:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">PL</span> <span class="fu">=</span> <span class="dt">PL</span></a>
<a class="sourceLine" id="cb2-2" title="2">  {<span class="ot"> name   ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-3" title="3">  ,<span class="ot"> year   ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-4" title="4">  ,<span class="ot"> person ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-5" title="5">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ot">pls ::</span> [<span class="dt">PL</span>]</a>
<a class="sourceLine" id="cb2-8" title="8">pls <span class="fu">=</span></a>
<a class="sourceLine" id="cb2-9" title="9">    [ <span class="dt">PL</span> <span class="st">&quot;Haskell&quot;</span> <span class="dv">1990</span> <span class="st">&quot;Simon&quot;</span></a>
<a class="sourceLine" id="cb2-10" title="10">    , <span class="dt">PL</span> <span class="st">&quot;Scala&quot;</span>   <span class="dv">2004</span> <span class="st">&quot;Martin&quot;</span></a>
<a class="sourceLine" id="cb2-11" title="11">    , <span class="dt">PL</span> <span class="st">&quot;Idris&quot;</span>   <span class="dv">2009</span> <span class="st">&quot;Edwin&quot;</span></a>
<a class="sourceLine" id="cb2-12" title="12">    , <span class="dt">PL</span> <span class="st">&quot;Perl&quot;</span>    <span class="dv">1987</span> <span class="st">&quot;Larry&quot;</span></a>
<a class="sourceLine" id="cb2-13" title="13">    ]</a>
<a class="sourceLine" id="cb2-14" title="14"></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="ot">input ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-16" title="16">input <span class="fu">=</span> T.unlines</a>
<a class="sourceLine" id="cb2-17" title="17">    [ <span class="st">&quot;year,name,types,person,website&quot;</span></a>
<a class="sourceLine" id="cb2-18" title="18">    , <span class="st">&quot;1987,Perl,no,Larry&quot;</span></a>
<a class="sourceLine" id="cb2-19" title="19">    , <span class="st">&quot;1990,Haskell,nice,Simon,https://www.haskell.org/&quot;</span></a>
<a class="sourceLine" id="cb2-20" title="20">    , <span class="st">&quot;2004,Scala,weird,Martin,https://www.scala-lang.org/&quot;</span></a>
<a class="sourceLine" id="cb2-21" title="21">    , <span class="st">&quot;2009,Idris,fancy,Edwin,https://www.idris-lang.org/&quot;</span></a>
<a class="sourceLine" id="cb2-22" title="22">    ]</a></code></pre></div>
<p>Here we have a simple record of programming language information. We have a list of a few languages, and we also have a sample CSV input. Note that the CSV input has extra fields, and it even has a missing website fields for one of the entries. We will see that since the <code>PL</code> type doesn’t have a <code>website</code> field, it won’t matter that the CSV data is missing that field.</p>
<h2 id="encoding-to-csv">Encoding to CSV</h2>
<p>I’m going to follow Oleg’s plan pretty closely, but instead of using vectors of <code>Text</code> as the intermediate value, I’ll be using an extensible row-types record.<br />
It’s very easy to convert the <code>PL</code> type into an row-types record: use the built-in <code>fromNative</code>. For instance:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> <span class="fu">:</span>t Rec.fromNative <span class="fu">&lt;$&gt;</span> pls</a>
<a class="sourceLine" id="cb3-2" title="2">Rec.fromNative <span class="fu">&lt;$&gt;</span> pls</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ot">  ::</span> [<span class="dt">Rec</span> (<span class="st">&quot;name&quot;</span> <span class="fu">.==</span> <span class="dt">Text</span> <span class="fu">.+</span> <span class="st">&quot;person&quot;</span> <span class="fu">.==</span> <span class="dt">Text</span> <span class="fu">.+</span> <span class="st">&quot;year&quot;</span> <span class="fu">.==</span> <span class="dt">Int</span>)]</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> Rec.fromNative <span class="fu">&lt;$&gt;</span> pls</a>
<a class="sourceLine" id="cb3-5" title="5">[<span class="fu">#</span>name <span class="fu">.==</span> <span class="st">&quot;Haskell&quot;</span> <span class="fu">.+</span> <span class="fu">#</span>person <span class="fu">.==</span> <span class="st">&quot;Simon&quot;</span> <span class="fu">.+</span> <span class="fu">#</span>year <span class="fu">.==</span> <span class="dv">1990</span></a>
<a class="sourceLine" id="cb3-6" title="6">,<span class="fu">#</span>name <span class="fu">.==</span> <span class="st">&quot;Scala&quot;</span> <span class="fu">.+</span> <span class="fu">#</span>person <span class="fu">.==</span> <span class="st">&quot;Martin&quot;</span> <span class="fu">.+</span> <span class="fu">#</span>year <span class="fu">.==</span> <span class="dv">2004</span></a>
<a class="sourceLine" id="cb3-7" title="7">,<span class="fu">#</span>name <span class="fu">.==</span> <span class="st">&quot;Idris&quot;</span> <span class="fu">.+</span> <span class="fu">#</span>person <span class="fu">.==</span> <span class="st">&quot;Edwin&quot;</span> <span class="fu">.+</span> <span class="fu">#</span>year <span class="fu">.==</span> <span class="dv">2009</span></a>
<a class="sourceLine" id="cb3-8" title="8">,<span class="fu">#</span>name <span class="fu">.==</span> <span class="st">&quot;Perl&quot;</span> <span class="fu">.+</span> <span class="fu">#</span>person <span class="fu">.==</span> <span class="st">&quot;Larry&quot;</span> <span class="fu">.+</span> <span class="fu">#</span>year <span class="fu">.==</span> <span class="dv">1987</span>]</a></code></pre></div>
<p>The ordering in row-types comes down to lexicographical ordering by field name, which is why it’s different here than in <code>PL</code>, but it’s not something we need to worry about because row-types are automatically normalized.</p>
<p>For the individual fields, let’s use the same <code>ToField</code> class that Oleg uses:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span>    <span class="dt">ToField</span> a    <span class="kw">where</span><span class="ot"> toField ::</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">instance</span> <span class="dt">ToField</span> <span class="dt">Text</span> <span class="kw">where</span> toField <span class="fu">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">instance</span> <span class="dt">ToField</span> <span class="dt">Int</span>  <span class="kw">where</span> toField <span class="fu">=</span> T.pack <span class="fu">.</span> <span class="fu">show</span></a></code></pre></div>
<p>And now, because we’re using row-types as our intermediate data type, we are ready to produce CSV data:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">recToCSV ::</span> <span class="kw">forall</span> ρ<span class="fu">.</span> <span class="dt">Forall</span> ρ <span class="dt">ToField</span> <span class="ot">=&gt;</span> [<span class="dt">Rec</span> ρ] <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-2" title="2">recToCSV rs <span class="fu">=</span> T.unlines <span class="fu">$</span> <span class="fu">map</span> (T.intercalate <span class="st">&quot;,&quot;</span>)</a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="fu">$</span> Rec.labels <span class="fu">@</span>ρ <span class="fu">@</span><span class="dt">ToField</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="fu">:</span> <span class="fu">map</span> (Rec.erase <span class="fu">@</span><span class="dt">ToField</span> toField) rs</a></code></pre></div>
<p>Let’s walk through this line by line. The first line is the type signature, where we demand that each field of the row-type <code>ρ</code> have a <code>ToField</code> instance. The second line should look pretty familiar: we stick commas between fields and turn a list of <code>Text</code>s into a <code>Text</code>. In the third line, we create the CSV header; the function <code>labels</code> returns the field names of a row type, and it only needs type arguments to work. The last line is where the individual records are encoded. The <code>erase</code> function is applied to each record in the input list; <code>erase</code> erases the field name information and maps the given function over the values, returning a simple list of results.</p>
<p>Lastly, we can make a general <code>toCSV</code> function by composing <code>fromNative</code> and <code>recToCSV</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">toCSV ::</span> <span class="kw">forall</span> ρ t<span class="fu">.</span> (<span class="dt">Rec.FromNative</span> t, <span class="dt">Rec.NativeRow</span> t ≈ ρ, <span class="dt">Forall</span> ρ <span class="dt">ToField</span>) <span class="ot">=&gt;</span> [t] <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-2" title="2">toCSV <span class="fu">=</span> recToCSV <span class="fu">@</span>ρ <span class="fu">.</span> <span class="fu">fmap</span> Rec.fromNative</a></code></pre></div>
<p>We can do a sanity check with:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> T.putStr <span class="fu">$</span> toCSV pls</a>
<a class="sourceLine" id="cb7-2" title="2">name,year,person</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="dt">Haskell</span>,<span class="dv">1990</span>,<span class="dt">Simon</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="dt">Scala</span>,<span class="dv">2004</span>,<span class="dt">Martin</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="dt">Idris</span>,<span class="dv">2009</span>,<span class="dt">Edwin</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="dt">Perl</span>,<span class="dv">1987</span>,<span class="dt">Larry</span></a></code></pre></div>
<h2 id="decoding-from-csv">Decoding from CSV</h2>
<p>Once again, we’ll use the same field conversion functions as Oleg:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">class</span>    <span class="dt">FromField</span> a    <span class="kw">where</span><span class="ot"> fromField ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">instance</span> <span class="dt">FromField</span> <span class="dt">Text</span> <span class="kw">where</span> fromField <span class="fu">=</span> <span class="dt">Right</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">instance</span> <span class="dt">FromField</span> <span class="dt">Int</span>  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" title="4">  fromField t <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-5" title="5">    <span class="fu">maybe</span> (<span class="dt">Left</span> <span class="fu">$</span> <span class="st">&quot;Invalid Int: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> t) <span class="dt">Right</span> <span class="fu">$</span> readMaybe <span class="fu">$</span> T.unpack t</a></code></pre></div>
<p>And with just this class, we’re immediately ready to parse the csv data:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">recFromCSV ::</span> <span class="kw">forall</span> ρ<span class="fu">.</span> (<span class="dt">AllUniqueLabels</span> ρ, <span class="dt">Forall</span> ρ <span class="dt">FromField</span>) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> [<span class="dt">Rec</span> ρ]</a>
<a class="sourceLine" id="cb9-2" title="2">recFromCSV s <span class="fu">=</span> <span class="kw">case</span> <span class="fu">map</span> (T.splitOn <span class="st">&quot;,&quot;</span>) (T.lines s) <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-3" title="3">  [] <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="st">&quot;No Input&quot;</span></a>
<a class="sourceLine" id="cb9-4" title="4">  header<span class="fu">:</span>vals <span class="ot">-&gt;</span> <span class="fu">traverse</span> makeRecord vals</a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-6" title="6">      makeRecord s <span class="fu">=</span> Rec.fromLabelsA <span class="fu">@</span><span class="dt">FromField</span> <span class="fu">@</span>(<span class="dt">Either</span> <span class="dt">String</span>) <span class="fu">@</span>ρ (makeField s)</a>
<a class="sourceLine" id="cb9-7" title="7"><span class="ot">      makeField ::</span> (<span class="dt">KnownSymbol</span> l, <span class="dt">FromField</span> a) <span class="ot">=&gt;</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Label</span> l <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</a>
<a class="sourceLine" id="cb9-8" title="8">      makeField val l <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-9" title="9">        <span class="fu">maybe</span> (<span class="dt">Left</span> <span class="fu">$</span> <span class="st">&quot;Missing field &quot;</span> <span class="fu">++</span> <span class="fu">show</span> l) fromField <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-10" title="10">          L.lookup (T.pack <span class="fu">$</span> <span class="fu">show</span> l) (<span class="fu">zip</span> header val)</a></code></pre></div>
<p>Let’s walk through this one line by line too. In the type signature, we’re demanding that the extensible record that we’re parsing have unique labels for every field—it wouldn’t make sense to have two different fields with the same name—and that each field has a <code>FromField</code> instance. The second line is just dealing with commas and lines, and the third line is dealing with bad input. On the fourth line, we separate the header from the rest of the lines. We then <code>traverse</code> each of the lines with the inner function <code>makeRecord</code>. The sixth line defines <code>makeRecord</code>, which uses the <code>fromLabelsA</code> (<code>A</code> for Applicative) function to construct a row-type record based on its field names. This in turn uses the <code>makeField</code> function, which takes the csv line and the label and returns either a <code>Left</code> error message if parsing fails or a <code>Right</code> value if it succeeds. Parsing is simply looking up the field name (<code>T.pack $ show l</code>) in the line and calling <code>fromField</code> on it.</p>
<p>Of course, we could probably do something smarter here than doing a lookup in a linked list—using a <code>Map</code> comes to mind—but we’re going for simplicity over efficiency for now.</p>
<p>Lastly, we can convert a value of type <code>Rec ρ</code> to a native Haskell data type with the row-types built-in <code>toNative</code>. This lets us write a general <code>fromCSV</code> function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">fromCSV ::</span> <span class="kw">forall</span> t ρ<span class="fu">.</span></a>
<a class="sourceLine" id="cb10-2" title="2">  (<span class="dt">Rec.ToNative</span> t, ρ ≈ <span class="dt">Rec.NativeRow</span> t, <span class="dt">AllUniqueLabels</span> ρ, <span class="dt">Forall</span> ρ <span class="dt">FromField</span>)</a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> [t]</a>
<a class="sourceLine" id="cb10-4" title="4">fromCSV <span class="fu">=</span> <span class="fu">fmap</span> (<span class="fu">fmap</span> Rec.toNative) <span class="fu">.</span> recFromCSV <span class="fu">@</span>ρ</a></code></pre></div>
<p>We can do a sanity check with:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-2" title="2">main <span class="fu">=</span> <span class="kw">case</span> fromCSV <span class="fu">@</span><span class="dt">PL</span> input <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;ERROR: &quot;</span> <span class="fu">++</span> err</a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="dt">Right</span> xs <span class="ot">-&gt;</span> <span class="fu">mapM_</span> <span class="fu">print</span> xs</a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> main</a>
<a class="sourceLine" id="cb11-7" title="7"><span class="dt">PL</span> {name <span class="fu">=</span> <span class="st">&quot;Perl&quot;</span>, year <span class="fu">=</span> <span class="dv">1987</span>, person <span class="fu">=</span> <span class="st">&quot;Larry&quot;</span>}</a>
<a class="sourceLine" id="cb11-8" title="8"><span class="dt">PL</span> {name <span class="fu">=</span> <span class="st">&quot;Haskell&quot;</span>, year <span class="fu">=</span> <span class="dv">1990</span>, person <span class="fu">=</span> <span class="st">&quot;Simon&quot;</span>}</a>
<a class="sourceLine" id="cb11-9" title="9"><span class="dt">PL</span> {name <span class="fu">=</span> <span class="st">&quot;Scala&quot;</span>, year <span class="fu">=</span> <span class="dv">2004</span>, person <span class="fu">=</span> <span class="st">&quot;Martin&quot;</span>}</a>
<a class="sourceLine" id="cb11-10" title="10"><span class="dt">PL</span> {name <span class="fu">=</span> <span class="st">&quot;Idris&quot;</span>, year <span class="fu">=</span> <span class="dv">2009</span>, person <span class="fu">=</span> <span class="st">&quot;Edwin&quot;</span>}</a></code></pre></div>
<h2 id="the-difficult-part">The Difficult Part</h2>
<p>There isn’t one! Notice that our first implementation of <code>recFromCSV</code> was perfectly able to handle data with missing fields and reordered columns, and it didn’t require any extra work on our part.</p>
<h2 id="conclusions-and-extensions">Conclusions and Extensions</h2>
<p>Oleg claims that row-types would not simplify anything in CSV encoding and decoding, but I must disagree. Not only did the row-types library give us free <code>fromNative</code> and <code>toNative</code> functions and heterogeneous type safety, but it handled all of the difficult cases of missing data and reordered columns for free as well.</p>
<p>Furthermore, if one thinks of the row-type record as an intermediate data type as described in the introduction, then we can extend this CSV parsing to incorporate the ideas of <a href="TypeSurgery.html">type surgery</a> as well. Instead of needing a <code>FromField</code> class, one could very simply lift the <code>Text</code> from the CSV into structured row-types records and then do surgery on them from there.</p>
    </section>
</article>

    </main>

    <footer>
      <quote>
        <blockquote data-animation-role="quote">
          quotetext
        </blockquote>
        <figcaption class="source">&mdash; quoteattrib</figcaption>
      </quote>
      <p> Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
    </footer>

  <script>
    var myQs = new Array();
    myQs[0] = "Real stupidity beats artificial intelligence every time. -- Terry Pratchett";
    myQs[1] = "He who wonders discovers that this in itself is wonder. -- M. C. Escher";
    myQs[2] = "Simplicity is the ultimate sophistication. -- Leonardo da Vinci";
    myQs[3] = "Time is like a drug. Too much of it kills you. -- Terry Pratchett";
    myQs[4] = "When it came to getting weird things done, sane beat mad hands down. -- Terry Pratchett";
    myQs[5] = "Students, eh? Love 'em or hate 'em, you're not allowed to hit 'em with a shovel. -- Terry Pratchett";
    myQs[6] = "You get ideas from daydreaming. You get ideas from being bored. You get ideas all the time. -- Neil Gaiman";
    myQs[7] = "I don't know half of you half as well as I should like; and I like less than half of you half as well as you deserve. -- Bilbo Baggins, from J.R.R Tolkien's Lord of the Rings";
    myQs[8] = "Only the insane equate pain with success. -- Cheshire Cat, from American Mcgee's Alice";
    myQs[9] = "Only a few find the way; some don't recognize it when they do; some don't ever want to. -- Cheshire Cat, from American Mcgee's Alice";
    myQs[10] = "Always collect what's useful. Reject only your ignorance, and you may survive. -- Cheshire Cat, from American Mcgee's Alice";
    myQs[11] = "Those who say there's nothing like a nice cup of tea for calming the nerves never had real tea. It's like a syringe of adrenaline straight to the heart! -- Cheshire Cat, from American Mcgee's Alice";
    myQs[12] = "My, Earth really is full of things -- King of All Cosmos, from Katamari Damacy";
    myQs[13] = "The way I see it, if you're going to build a time machine into a car, why not do it with some style? -- Doc, from Back to the Future";
    myQs[14] = "I know because I was there. -- Wadsworth, from Clue";
    myQs[15] = "No meaning yes, or no meaning no? -- Colonel Mustard, from Clue";
    myQs[16] = "I feel like I could... like I could... like I could... TAKE ON THE WORLD!! -- Purple Tentacle, from Day of the Tentacle";
    myQs[17] = "You know what they say: \"If you want to save the world, you have to push a few old ladies down the stairs\". -- Bernard, from Day of the Tentacle";
    myQs[18] = "Wait, I’ve got an idea, and it doesn’t require high explosives. -- Max, from Sam'n'Max Hit the Road";
    myQs[19] = "You have this really convenient subspace highway running through your head that I like to use. It's, like, 3 miles in 15 seconds. -- Ramona, from Scott Pilgrim vs The World";
    myQs[20] = "Do you think that's air you're breathing now?  Stop trying to hit me and hit me! -- Morpheus, from The Matrix";
    myQs[21] = "Ray, when someone asks you if you're a god, you say \"Yes!\" -- Winston, from Ghostbusters";
    myQs[22] = "So, Lone Starr, now you see that evil will always triumph, because good is dumb. -- Dark Helmet, from Spaceballs";
    myQs[23] = "People assume that time is a strict progression of cause to effect, but actually — from a non-linear, non-subjective viewpoint — it's more like a big ball of wibbly-wobbly... timey-wimey... stuff. -- Doctor Who";
    myQs[24] = "I must not fear. Fear is the mind-killer. Fear is the little-death that brings total obliteration. -- Paul Atreides, from Frank Herbert's Dune";
    myQs[25] = "Science fiction writers foresee the inevitable, and although problems and catastrophes may be inevitable, solutions are not. -- Isaac Asimov";
    myQs[26] = "To succeed, planning alone is insufficient. One must improvise as well. -- Isaac Asimov";
    myQs[27] = "Remember - the enemy's gate is down. -- Ender, from Orson Scott Card's Ender's Game";
    myQs[28] = "Space is big. Really big. You just won't believe how vastly, hugely, mindbogglingly big it is. I mean, you may think it's a long way down the road to the chemist's, but that's just peanuts to space. -- Douglas Adams, The Hitchhiker's Guide to the Galaxy";
    myQs[29] = "The chances of finding out what's really going on in the universe are so remote, the only thing to do is hang the sense of it and keep yourself occupied. -- Douglas Adams, The Hitchhiker's Guide to the Galaxy";
    myQs[30] = "Hey, you sass that hoopy Ford Prefect? There's a frood who really knows where his towel is. -- Douglas Adams, The Hitchhiker's Guide to the Galaxy";
    myQs[31] = "There's always money in the banana stand. -- George Bluth, from Arrested Development";
    myQs[32] = "Introducing \"the double decker couch\", so everyone could watch TV together and be buddies! -- Emmet, from The Lego Movie";
    myQs[33] = "Ah! Curse your sudden but inevitable betrayal! -- Wash, from Firefly";
    myQs[34] = "Nothing can happen till you swing the bat. -- Haruko, from FLCL";
    myQs[35] = "Dear God. What is it like in your funny little brains? It must be so boring. -- Sherlock";
    myQs[36] = "You, [subject name here], must be the pride of [subject hometown here]! -- GLaDOS, from Portal";
    myQs[37] = "Please note that we have added a consequence for failure. Any contact with the chamber floor will result in an \"unsatisfactory\" mark on your official testing record, followed by death. Good luck! -- GLaDOS, from Portal";
    myQs[38] = "Did you know you can donate one or all of your vital organs to the Aperture Science Self-Esteem Fund for Girls? It's true! -- GLaDOS, from Portal";
    myQs[39] = "You euthanized your faithful Companion Cube more quickly than any test subject on record. Congratulations. -- GLaDOS, from Portal";
    myQs[40] = "Look at me still talking when there's Science to do -- GLaDOS, from Portal";
    myQs[41] = "The Human Mind: 600 miles of synaptic fiber, five and a half ounces of cranial fluid, 1500 grams of complex neural matter... a three-pound pile of dreams. -- Raz, from Psychonauts";


    var range = myQs.length;
    var index;
    var quote;
    var res;
    var attribution;
    var bodyGrab;

    function getQuote()
    {
      index = Math.floor(Math.random()*range);
      quote = myQs[index];
      res = quote.split(" -- ");
      quote = res[0];
      attribution = res[1];
    }

    var blocks = document.getElementsByTagName("blockquote");
    var captions = document.getElementsByTagName("figcaption");
    for (var i=0;i<blocks.length;i++)
    {
      getQuote();
      bodyGrab = blocks[i].innerHTML;
      bodyGrab = bodyGrab.replace("quotetext", quote);
      blocks[i].innerHTML = bodyGrab;
      bodyGrab = captions[i].innerHTML;
      bodyGrab = bodyGrab.replace("quoteattrib", attribution);
      captions[i].innerHTML = bodyGrab;
    }
  </script>
  </body>
</html>
